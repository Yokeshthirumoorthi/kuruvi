// Code generated by protoc-gen-go. DO NOT EDIT.
// source: kuruvi.proto

package kuruvi

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type Empty struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Empty) Reset()         { *m = Empty{} }
func (m *Empty) String() string { return proto.CompactTextString(m) }
func (*Empty) ProtoMessage()    {}
func (*Empty) Descriptor() ([]byte, []int) {
	return fileDescriptor_cccbc20a9ea5cc3a, []int{0}
}

func (m *Empty) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Empty.Unmarshal(m, b)
}
func (m *Empty) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Empty.Marshal(b, m, deterministic)
}
func (m *Empty) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Empty.Merge(m, src)
}
func (m *Empty) XXX_Size() int {
	return xxx_messageInfo_Empty.Size(m)
}
func (m *Empty) XXX_DiscardUnknown() {
	xxx_messageInfo_Empty.DiscardUnknown(m)
}

var xxx_messageInfo_Empty proto.InternalMessageInfo

type AlbumFolder struct {
	AlbumName            string   `protobuf:"bytes,1,opt,name=albumName,proto3" json:"albumName,omitempty"`
	Photos               []string `protobuf:"bytes,2,rep,name=photos,proto3" json:"photos,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AlbumFolder) Reset()         { *m = AlbumFolder{} }
func (m *AlbumFolder) String() string { return proto.CompactTextString(m) }
func (*AlbumFolder) ProtoMessage()    {}
func (*AlbumFolder) Descriptor() ([]byte, []int) {
	return fileDescriptor_cccbc20a9ea5cc3a, []int{1}
}

func (m *AlbumFolder) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AlbumFolder.Unmarshal(m, b)
}
func (m *AlbumFolder) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AlbumFolder.Marshal(b, m, deterministic)
}
func (m *AlbumFolder) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AlbumFolder.Merge(m, src)
}
func (m *AlbumFolder) XXX_Size() int {
	return xxx_messageInfo_AlbumFolder.Size(m)
}
func (m *AlbumFolder) XXX_DiscardUnknown() {
	xxx_messageInfo_AlbumFolder.DiscardUnknown(m)
}

var xxx_messageInfo_AlbumFolder proto.InternalMessageInfo

func (m *AlbumFolder) GetAlbumName() string {
	if m != nil {
		return m.AlbumName
	}
	return ""
}

func (m *AlbumFolder) GetPhotos() []string {
	if m != nil {
		return m.Photos
	}
	return nil
}

type DescribeFaceRequest struct {
	AlbumName            string   `protobuf:"bytes,1,opt,name=albumName,proto3" json:"albumName,omitempty"`
	PhotoName            string   `protobuf:"bytes,2,opt,name=photoName,proto3" json:"photoName,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DescribeFaceRequest) Reset()         { *m = DescribeFaceRequest{} }
func (m *DescribeFaceRequest) String() string { return proto.CompactTextString(m) }
func (*DescribeFaceRequest) ProtoMessage()    {}
func (*DescribeFaceRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_cccbc20a9ea5cc3a, []int{2}
}

func (m *DescribeFaceRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DescribeFaceRequest.Unmarshal(m, b)
}
func (m *DescribeFaceRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DescribeFaceRequest.Marshal(b, m, deterministic)
}
func (m *DescribeFaceRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DescribeFaceRequest.Merge(m, src)
}
func (m *DescribeFaceRequest) XXX_Size() int {
	return xxx_messageInfo_DescribeFaceRequest.Size(m)
}
func (m *DescribeFaceRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DescribeFaceRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DescribeFaceRequest proto.InternalMessageInfo

func (m *DescribeFaceRequest) GetAlbumName() string {
	if m != nil {
		return m.AlbumName
	}
	return ""
}

func (m *DescribeFaceRequest) GetPhotoName() string {
	if m != nil {
		return m.PhotoName
	}
	return ""
}

// remote url of photo for exif extraction
type PhotoURL struct {
	Url                  string   `protobuf:"bytes,1,opt,name=url,proto3" json:"url,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PhotoURL) Reset()         { *m = PhotoURL{} }
func (m *PhotoURL) String() string { return proto.CompactTextString(m) }
func (*PhotoURL) ProtoMessage()    {}
func (*PhotoURL) Descriptor() ([]byte, []int) {
	return fileDescriptor_cccbc20a9ea5cc3a, []int{3}
}

func (m *PhotoURL) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PhotoURL.Unmarshal(m, b)
}
func (m *PhotoURL) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PhotoURL.Marshal(b, m, deterministic)
}
func (m *PhotoURL) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PhotoURL.Merge(m, src)
}
func (m *PhotoURL) XXX_Size() int {
	return xxx_messageInfo_PhotoURL.Size(m)
}
func (m *PhotoURL) XXX_DiscardUnknown() {
	xxx_messageInfo_PhotoURL.DiscardUnknown(m)
}

var xxx_messageInfo_PhotoURL proto.InternalMessageInfo

func (m *PhotoURL) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

// exif details extracted from a photo
type ExifData struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Make                 string   `protobuf:"bytes,2,opt,name=make,proto3" json:"make,omitempty"`
	Model                string   `protobuf:"bytes,3,opt,name=model,proto3" json:"model,omitempty"`
	CreateOn             int32    `protobuf:"varint,4,opt,name=create_on,json=createOn,proto3" json:"create_on,omitempty"`
	Width                int32    `protobuf:"varint,5,opt,name=width,proto3" json:"width,omitempty"`
	Height               int32    `protobuf:"varint,6,opt,name=height,proto3" json:"height,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ExifData) Reset()         { *m = ExifData{} }
func (m *ExifData) String() string { return proto.CompactTextString(m) }
func (*ExifData) ProtoMessage()    {}
func (*ExifData) Descriptor() ([]byte, []int) {
	return fileDescriptor_cccbc20a9ea5cc3a, []int{4}
}

func (m *ExifData) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ExifData.Unmarshal(m, b)
}
func (m *ExifData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ExifData.Marshal(b, m, deterministic)
}
func (m *ExifData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExifData.Merge(m, src)
}
func (m *ExifData) XXX_Size() int {
	return xxx_messageInfo_ExifData.Size(m)
}
func (m *ExifData) XXX_DiscardUnknown() {
	xxx_messageInfo_ExifData.DiscardUnknown(m)
}

var xxx_messageInfo_ExifData proto.InternalMessageInfo

func (m *ExifData) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ExifData) GetMake() string {
	if m != nil {
		return m.Make
	}
	return ""
}

func (m *ExifData) GetModel() string {
	if m != nil {
		return m.Model
	}
	return ""
}

func (m *ExifData) GetCreateOn() int32 {
	if m != nil {
		return m.CreateOn
	}
	return 0
}

func (m *ExifData) GetWidth() int32 {
	if m != nil {
		return m.Width
	}
	return 0
}

func (m *ExifData) GetHeight() int32 {
	if m != nil {
		return m.Height
	}
	return 0
}

// message to acknowledge the status
type JobStatus struct {
	Success              int32    `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	Error                int32    `protobuf:"varint,2,opt,name=error,proto3" json:"error,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *JobStatus) Reset()         { *m = JobStatus{} }
func (m *JobStatus) String() string { return proto.CompactTextString(m) }
func (*JobStatus) ProtoMessage()    {}
func (*JobStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_cccbc20a9ea5cc3a, []int{5}
}

func (m *JobStatus) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_JobStatus.Unmarshal(m, b)
}
func (m *JobStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_JobStatus.Marshal(b, m, deterministic)
}
func (m *JobStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JobStatus.Merge(m, src)
}
func (m *JobStatus) XXX_Size() int {
	return xxx_messageInfo_JobStatus.Size(m)
}
func (m *JobStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_JobStatus.DiscardUnknown(m)
}

var xxx_messageInfo_JobStatus proto.InternalMessageInfo

func (m *JobStatus) GetSuccess() int32 {
	if m != nil {
		return m.Success
	}
	return 0
}

func (m *JobStatus) GetError() int32 {
	if m != nil {
		return m.Error
	}
	return 0
}

type BoundingBox struct {
	X                    float32  `protobuf:"fixed32,2,opt,name=x,proto3" json:"x,omitempty"`
	Y                    float32  `protobuf:"fixed32,3,opt,name=y,proto3" json:"y,omitempty"`
	Width                int32    `protobuf:"varint,4,opt,name=width,proto3" json:"width,omitempty"`
	Height               int32    `protobuf:"varint,5,opt,name=height,proto3" json:"height,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BoundingBox) Reset()         { *m = BoundingBox{} }
func (m *BoundingBox) String() string { return proto.CompactTextString(m) }
func (*BoundingBox) ProtoMessage()    {}
func (*BoundingBox) Descriptor() ([]byte, []int) {
	return fileDescriptor_cccbc20a9ea5cc3a, []int{6}
}

func (m *BoundingBox) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BoundingBox.Unmarshal(m, b)
}
func (m *BoundingBox) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BoundingBox.Marshal(b, m, deterministic)
}
func (m *BoundingBox) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BoundingBox.Merge(m, src)
}
func (m *BoundingBox) XXX_Size() int {
	return xxx_messageInfo_BoundingBox.Size(m)
}
func (m *BoundingBox) XXX_DiscardUnknown() {
	xxx_messageInfo_BoundingBox.DiscardUnknown(m)
}

var xxx_messageInfo_BoundingBox proto.InternalMessageInfo

func (m *BoundingBox) GetX() float32 {
	if m != nil {
		return m.X
	}
	return 0
}

func (m *BoundingBox) GetY() float32 {
	if m != nil {
		return m.Y
	}
	return 0
}

func (m *BoundingBox) GetWidth() int32 {
	if m != nil {
		return m.Width
	}
	return 0
}

func (m *BoundingBox) GetHeight() int32 {
	if m != nil {
		return m.Height
	}
	return 0
}

type BoundingBoxes struct {
	Boxes                []*BoundingBox `protobuf:"bytes,1,rep,name=boxes,proto3" json:"boxes,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *BoundingBoxes) Reset()         { *m = BoundingBoxes{} }
func (m *BoundingBoxes) String() string { return proto.CompactTextString(m) }
func (*BoundingBoxes) ProtoMessage()    {}
func (*BoundingBoxes) Descriptor() ([]byte, []int) {
	return fileDescriptor_cccbc20a9ea5cc3a, []int{7}
}

func (m *BoundingBoxes) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BoundingBoxes.Unmarshal(m, b)
}
func (m *BoundingBoxes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BoundingBoxes.Marshal(b, m, deterministic)
}
func (m *BoundingBoxes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BoundingBoxes.Merge(m, src)
}
func (m *BoundingBoxes) XXX_Size() int {
	return xxx_messageInfo_BoundingBoxes.Size(m)
}
func (m *BoundingBoxes) XXX_DiscardUnknown() {
	xxx_messageInfo_BoundingBoxes.DiscardUnknown(m)
}

var xxx_messageInfo_BoundingBoxes proto.InternalMessageInfo

func (m *BoundingBoxes) GetBoxes() []*BoundingBox {
	if m != nil {
		return m.Boxes
	}
	return nil
}

type FacePoints struct {
	Points               []float32 `protobuf:"fixed32,1,rep,packed,name=points,proto3" json:"points,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *FacePoints) Reset()         { *m = FacePoints{} }
func (m *FacePoints) String() string { return proto.CompactTextString(m) }
func (*FacePoints) ProtoMessage()    {}
func (*FacePoints) Descriptor() ([]byte, []int) {
	return fileDescriptor_cccbc20a9ea5cc3a, []int{8}
}

func (m *FacePoints) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FacePoints.Unmarshal(m, b)
}
func (m *FacePoints) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FacePoints.Marshal(b, m, deterministic)
}
func (m *FacePoints) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FacePoints.Merge(m, src)
}
func (m *FacePoints) XXX_Size() int {
	return xxx_messageInfo_FacePoints.Size(m)
}
func (m *FacePoints) XXX_DiscardUnknown() {
	xxx_messageInfo_FacePoints.DiscardUnknown(m)
}

var xxx_messageInfo_FacePoints proto.InternalMessageInfo

func (m *FacePoints) GetPoints() []float32 {
	if m != nil {
		return m.Points
	}
	return nil
}

type CropFacesRequest struct {
	AlbumName            string         `protobuf:"bytes,1,opt,name=albumName,proto3" json:"albumName,omitempty"`
	PhotoName            string         `protobuf:"bytes,2,opt,name=photoName,proto3" json:"photoName,omitempty"`
	BoundingBoxes        []*BoundingBox `protobuf:"bytes,3,rep,name=boundingBoxes,proto3" json:"boundingBoxes,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *CropFacesRequest) Reset()         { *m = CropFacesRequest{} }
func (m *CropFacesRequest) String() string { return proto.CompactTextString(m) }
func (*CropFacesRequest) ProtoMessage()    {}
func (*CropFacesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_cccbc20a9ea5cc3a, []int{9}
}

func (m *CropFacesRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CropFacesRequest.Unmarshal(m, b)
}
func (m *CropFacesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CropFacesRequest.Marshal(b, m, deterministic)
}
func (m *CropFacesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CropFacesRequest.Merge(m, src)
}
func (m *CropFacesRequest) XXX_Size() int {
	return xxx_messageInfo_CropFacesRequest.Size(m)
}
func (m *CropFacesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CropFacesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CropFacesRequest proto.InternalMessageInfo

func (m *CropFacesRequest) GetAlbumName() string {
	if m != nil {
		return m.AlbumName
	}
	return ""
}

func (m *CropFacesRequest) GetPhotoName() string {
	if m != nil {
		return m.PhotoName
	}
	return ""
}

func (m *CropFacesRequest) GetBoundingBoxes() []*BoundingBox {
	if m != nil {
		return m.BoundingBoxes
	}
	return nil
}

func init() {
	proto.RegisterType((*Empty)(nil), "kuruvi.Empty")
	proto.RegisterType((*AlbumFolder)(nil), "kuruvi.AlbumFolder")
	proto.RegisterType((*DescribeFaceRequest)(nil), "kuruvi.DescribeFaceRequest")
	proto.RegisterType((*PhotoURL)(nil), "kuruvi.PhotoURL")
	proto.RegisterType((*ExifData)(nil), "kuruvi.ExifData")
	proto.RegisterType((*JobStatus)(nil), "kuruvi.JobStatus")
	proto.RegisterType((*BoundingBox)(nil), "kuruvi.BoundingBox")
	proto.RegisterType((*BoundingBoxes)(nil), "kuruvi.BoundingBoxes")
	proto.RegisterType((*FacePoints)(nil), "kuruvi.FacePoints")
	proto.RegisterType((*CropFacesRequest)(nil), "kuruvi.CropFacesRequest")
}

func init() { proto.RegisterFile("kuruvi.proto", fileDescriptor_cccbc20a9ea5cc3a) }

var fileDescriptor_cccbc20a9ea5cc3a = []byte{
	// 673 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x55, 0x4d, 0x4f, 0x1b, 0x3b,
	0x14, 0xcd, 0x24, 0x4c, 0x3e, 0x6e, 0x92, 0xf7, 0xc0, 0xbc, 0xf7, 0x34, 0x02, 0x16, 0xd1, 0xe8,
	0x2d, 0xd2, 0x0d, 0x8b, 0xd0, 0x05, 0xa5, 0xaa, 0x0a, 0x24, 0xa4, 0x52, 0x5b, 0xb5, 0x74, 0xa2,
	0x8a, 0xee, 0x2a, 0x67, 0x72, 0x49, 0x2c, 0x26, 0xe3, 0xc1, 0xf6, 0x40, 0xc2, 0x3f, 0xe8, 0xba,
	0x7f, 0xb8, 0xb2, 0x3d, 0x93, 0x84, 0x36, 0xa8, 0x20, 0x75, 0xe7, 0x73, 0x7c, 0xef, 0xc9, 0xb1,
	0xef, 0x19, 0x07, 0x1a, 0x57, 0xa9, 0x48, 0x6f, 0xd8, 0x7e, 0x22, 0xb8, 0xe2, 0xa4, 0x6c, 0x91,
	0x5f, 0x01, 0xf7, 0x6c, 0x9a, 0xa8, 0xb9, 0xdf, 0x85, 0xfa, 0x49, 0x34, 0x4c, 0xa7, 0x7d, 0x1e,
	0x8d, 0x50, 0x90, 0x3d, 0xa8, 0x51, 0x0d, 0x3f, 0xd0, 0x29, 0x7a, 0x4e, 0xcb, 0x69, 0xd7, 0x82,
	0x25, 0x41, 0xfe, 0x83, 0x72, 0x32, 0xe1, 0x8a, 0x4b, 0xaf, 0xd8, 0x2a, 0xb5, 0x6b, 0x41, 0x86,
	0xfc, 0x4f, 0xb0, 0xdd, 0x43, 0x19, 0x0a, 0x36, 0xc4, 0x3e, 0x0d, 0x31, 0xc0, 0xeb, 0x14, 0xa5,
	0xfa, 0x8d, 0xd8, 0x1e, 0xd4, 0x4c, 0xbb, 0xd9, 0x2d, 0xda, 0xdd, 0x05, 0xe1, 0xef, 0x41, 0xf5,
	0x5c, 0x83, 0xcf, 0xc1, 0x7b, 0xb2, 0x09, 0xa5, 0x54, 0x44, 0x99, 0x82, 0x5e, 0xfa, 0xdf, 0x1d,
	0xa8, 0x9e, 0xcd, 0xd8, 0x65, 0x8f, 0x2a, 0x4a, 0x08, 0x6c, 0xc4, 0xcb, 0x5f, 0x30, 0x6b, 0xcd,
	0x4d, 0xe9, 0x55, 0xae, 0x6b, 0xd6, 0xe4, 0x1f, 0x70, 0xa7, 0x7c, 0x84, 0x91, 0x57, 0x32, 0xa4,
	0x05, 0x64, 0x17, 0x6a, 0xa1, 0x40, 0xaa, 0xf0, 0x2b, 0x8f, 0xbd, 0x8d, 0x96, 0xd3, 0x76, 0x83,
	0xaa, 0x25, 0x3e, 0xc6, 0xba, 0xe5, 0x96, 0x8d, 0xd4, 0xc4, 0x73, 0xcd, 0x86, 0x05, 0xfa, 0x1a,
	0x26, 0xc8, 0xc6, 0x13, 0xe5, 0x95, 0x0d, 0x9d, 0x21, 0xff, 0x25, 0xd4, 0xde, 0xf2, 0xe1, 0x40,
	0x51, 0x95, 0x4a, 0xe2, 0x41, 0x45, 0xa6, 0x61, 0x88, 0x52, 0x1a, 0x63, 0x6e, 0x90, 0x43, 0x2d,
	0x8a, 0x42, 0x70, 0x61, 0xcc, 0xb9, 0x81, 0x05, 0xfe, 0x05, 0xd4, 0x4f, 0x79, 0x1a, 0x8f, 0x58,
	0x3c, 0x3e, 0xe5, 0x33, 0xd2, 0x00, 0x67, 0x66, 0x0a, 0x8a, 0x81, 0x63, 0xd0, 0xdc, 0xd8, 0x2e,
	0x06, 0xce, 0x7c, 0xe9, 0x6a, 0x63, 0xbd, 0x2b, 0xf7, 0x9e, 0xab, 0x23, 0x68, 0xae, 0x08, 0xa3,
	0x24, 0xcf, 0xc0, 0x1d, 0xea, 0x85, 0xe7, 0xb4, 0x4a, 0xed, 0x7a, 0x67, 0x7b, 0x3f, 0x4b, 0xc8,
	0x4a, 0x55, 0x60, 0x2b, 0xfc, 0xff, 0x01, 0xf4, 0x40, 0xcf, 0x39, 0x8b, 0x95, 0x34, 0xe3, 0x37,
	0x2b, 0xd3, 0x59, 0x0c, 0x32, 0xe4, 0x7f, 0x73, 0x60, 0xb3, 0x2b, 0x78, 0xa2, 0x4b, 0xe5, 0x1f,
	0x18, 0x3e, 0x79, 0x01, 0xcd, 0xe1, 0xaa, 0x65, 0xaf, 0xf4, 0xb0, 0xd3, 0xfb, 0x95, 0x9d, 0x63,
	0xa8, 0x0e, 0x50, 0xdc, 0xb0, 0x10, 0xbf, 0x90, 0xe7, 0xd0, 0x60, 0x31, 0x53, 0x17, 0x5c, 0x5c,
	0xf5, 0x23, 0x7e, 0x4b, 0x16, 0xfd, 0x2b, 0x89, 0xdf, 0x69, 0xe6, 0xa4, 0xfd, 0x1e, 0x0a, 0x9d,
	0x01, 0xfc, 0xad, 0x47, 0xc8, 0xc2, 0x37, 0x18, 0xa3, 0xa0, 0x8a, 0x0b, 0x72, 0x0c, 0x9e, 0x8d,
	0x84, 0xdd, 0xb8, 0xc0, 0x61, 0x8f, 0x09, 0x0c, 0x15, 0x17, 0xf3, 0x47, 0x8a, 0xbe, 0xb6, 0x79,
	0xed, 0x72, 0x81, 0xe4, 0x00, 0xea, 0x38, 0x53, 0x82, 0x86, 0x4a, 0x53, 0x64, 0x33, 0xaf, 0xcd,
	0xf3, 0xbe, 0xb3, 0x60, 0xf2, 0x88, 0xfb, 0x85, 0x4e, 0x17, 0x2a, 0x1a, 0x9d, 0x24, 0x8c, 0x1c,
	0x42, 0x03, 0x67, 0xec, 0x92, 0x5d, 0xce, 0xcd, 0x4f, 0xae, 0x77, 0xb0, 0x95, 0x93, 0x8b, 0x44,
	0xfa, 0x85, 0xce, 0x19, 0x54, 0xf4, 0x8c, 0xb4, 0xc8, 0x11, 0xfc, 0x15, 0x0a, 0x9e, 0xd8, 0x16,
	0x3d, 0xb7, 0x27, 0xc8, 0xf4, 0xa0, 0xaa, 0x5b, 0xcc, 0x61, 0x0e, 0xa1, 0x3e, 0x42, 0x85, 0xa1,
	0xb2, 0x22, 0xbf, 0x1e, 0xe6, 0xdf, 0x35, 0x43, 0x43, 0xad, 0x12, 0x40, 0x43, 0xf7, 0xe4, 0x0f,
	0x07, 0x39, 0x85, 0xe6, 0x68, 0xe5, 0x11, 0x91, 0x64, 0x37, 0xef, 0x5c, 0xf3, 0xb6, 0xec, 0x90,
	0x7c, 0x73, 0x99, 0x4f, 0xbf, 0xd0, 0xe9, 0x67, 0xce, 0x04, 0x4f, 0xc8, 0x91, 0xfe, 0xb0, 0xb3,
	0x50, 0x12, 0x2f, 0x2f, 0xff, 0x39, 0xa7, 0x0f, 0x5d, 0x54, 0x2d, 0x40, 0xc9, 0xee, 0x30, 0xbb,
	0x6f, 0x61, 0x80, 0x39, 0xd3, 0x53, 0x2e, 0xea, 0x1d, 0xc0, 0x40, 0x71, 0x41, 0xc7, 0x46, 0xe7,
	0x15, 0x6c, 0x49, 0x7a, 0x83, 0xb6, 0xa1, 0x87, 0x8a, 0xb2, 0xe8, 0x89, 0xb7, 0x7e, 0x3e, 0x96,
	0xd7, 0x51, 0x66, 0x89, 0x8b, 0x31, 0x8d, 0xd9, 0x1d, 0x9a, 0x27, 0xf0, 0xd1, 0x2a, 0xc3, 0xb2,
	0xf9, 0x1f, 0x38, 0xf8, 0x11, 0x00, 0x00, 0xff, 0xff, 0x35, 0xa1, 0x69, 0xbb, 0x17, 0x06, 0x00,
	0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// ServiceXClient is the client API for ServiceX service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ServiceXClient interface {
	// A Simple RPC
	//
	// It will execute a set of workflow
	// and extracts more details about the photo
	InitWorkFlow(ctx context.Context, in *AlbumFolder, opts ...grpc.CallOption) (*Empty, error)
}

type serviceXClient struct {
	cc *grpc.ClientConn
}

func NewServiceXClient(cc *grpc.ClientConn) ServiceXClient {
	return &serviceXClient{cc}
}

func (c *serviceXClient) InitWorkFlow(ctx context.Context, in *AlbumFolder, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/kuruvi.ServiceX/initWorkFlow", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ServiceXServer is the server API for ServiceX service.
type ServiceXServer interface {
	// A Simple RPC
	//
	// It will execute a set of workflow
	// and extracts more details about the photo
	InitWorkFlow(context.Context, *AlbumFolder) (*Empty, error)
}

// UnimplementedServiceXServer can be embedded to have forward compatible implementations.
type UnimplementedServiceXServer struct {
}

func (*UnimplementedServiceXServer) InitWorkFlow(ctx context.Context, req *AlbumFolder) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InitWorkFlow not implemented")
}

func RegisterServiceXServer(s *grpc.Server, srv ServiceXServer) {
	s.RegisterService(&_ServiceX_serviceDesc, srv)
}

func _ServiceX_InitWorkFlow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AlbumFolder)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServiceXServer).InitWorkFlow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kuruvi.ServiceX/InitWorkFlow",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServiceXServer).InitWorkFlow(ctx, req.(*AlbumFolder))
	}
	return interceptor(ctx, in, info, handler)
}

var _ServiceX_serviceDesc = grpc.ServiceDesc{
	ServiceName: "kuruvi.ServiceX",
	HandlerType: (*ServiceXServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "initWorkFlow",
			Handler:    _ServiceX_InitWorkFlow_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "kuruvi.proto",
}

// StaticGeneratorClient is the client API for StaticGenerator service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type StaticGeneratorClient interface {
	// A Simple RPC
	//
	// Creates the web directory with js, html and the
	// cache contents
	CreateStaticWebDirectory(ctx context.Context, in *AlbumFolder, opts ...grpc.CallOption) (*Empty, error)
}

type staticGeneratorClient struct {
	cc *grpc.ClientConn
}

func NewStaticGeneratorClient(cc *grpc.ClientConn) StaticGeneratorClient {
	return &staticGeneratorClient{cc}
}

func (c *staticGeneratorClient) CreateStaticWebDirectory(ctx context.Context, in *AlbumFolder, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/kuruvi.StaticGenerator/createStaticWebDirectory", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// StaticGeneratorServer is the server API for StaticGenerator service.
type StaticGeneratorServer interface {
	// A Simple RPC
	//
	// Creates the web directory with js, html and the
	// cache contents
	CreateStaticWebDirectory(context.Context, *AlbumFolder) (*Empty, error)
}

// UnimplementedStaticGeneratorServer can be embedded to have forward compatible implementations.
type UnimplementedStaticGeneratorServer struct {
}

func (*UnimplementedStaticGeneratorServer) CreateStaticWebDirectory(ctx context.Context, req *AlbumFolder) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateStaticWebDirectory not implemented")
}

func RegisterStaticGeneratorServer(s *grpc.Server, srv StaticGeneratorServer) {
	s.RegisterService(&_StaticGenerator_serviceDesc, srv)
}

func _StaticGenerator_CreateStaticWebDirectory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AlbumFolder)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StaticGeneratorServer).CreateStaticWebDirectory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kuruvi.StaticGenerator/CreateStaticWebDirectory",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StaticGeneratorServer).CreateStaticWebDirectory(ctx, req.(*AlbumFolder))
	}
	return interceptor(ctx, in, info, handler)
}

var _StaticGenerator_serviceDesc = grpc.ServiceDesc{
	ServiceName: "kuruvi.StaticGenerator",
	HandlerType: (*StaticGeneratorServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "createStaticWebDirectory",
			Handler:    _StaticGenerator_CreateStaticWebDirectory_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "kuruvi.proto",
}

// ExifCoreClient is the client API for ExifCore service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ExifCoreClient interface {
	// A Simple RPC
	//
	// Downloads photo from remote server and extracts exif
	ExtractExif(ctx context.Context, in *PhotoURL, opts ...grpc.CallOption) (*ExifData, error)
}

type exifCoreClient struct {
	cc *grpc.ClientConn
}

func NewExifCoreClient(cc *grpc.ClientConn) ExifCoreClient {
	return &exifCoreClient{cc}
}

func (c *exifCoreClient) ExtractExif(ctx context.Context, in *PhotoURL, opts ...grpc.CallOption) (*ExifData, error) {
	out := new(ExifData)
	err := c.cc.Invoke(ctx, "/kuruvi.ExifCore/extractExif", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ExifCoreServer is the server API for ExifCore service.
type ExifCoreServer interface {
	// A Simple RPC
	//
	// Downloads photo from remote server and extracts exif
	ExtractExif(context.Context, *PhotoURL) (*ExifData, error)
}

// UnimplementedExifCoreServer can be embedded to have forward compatible implementations.
type UnimplementedExifCoreServer struct {
}

func (*UnimplementedExifCoreServer) ExtractExif(ctx context.Context, req *PhotoURL) (*ExifData, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ExtractExif not implemented")
}

func RegisterExifCoreServer(s *grpc.Server, srv ExifCoreServer) {
	s.RegisterService(&_ExifCore_serviceDesc, srv)
}

func _ExifCore_ExtractExif_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PhotoURL)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExifCoreServer).ExtractExif(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kuruvi.ExifCore/ExtractExif",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExifCoreServer).ExtractExif(ctx, req.(*PhotoURL))
	}
	return interceptor(ctx, in, info, handler)
}

var _ExifCore_serviceDesc = grpc.ServiceDesc{
	ServiceName: "kuruvi.ExifCore",
	HandlerType: (*ExifCoreServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "extractExif",
			Handler:    _ExifCore_ExtractExif_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "kuruvi.proto",
}

// ExifApiClient is the client API for ExifApi service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ExifApiClient interface {
	// A Simple RPC
	//
	// Gets the exif details of all photos in an album
	// and save it to database
	ExififyAlbum(ctx context.Context, in *AlbumFolder, opts ...grpc.CallOption) (*JobStatus, error)
}

type exifApiClient struct {
	cc *grpc.ClientConn
}

func NewExifApiClient(cc *grpc.ClientConn) ExifApiClient {
	return &exifApiClient{cc}
}

func (c *exifApiClient) ExififyAlbum(ctx context.Context, in *AlbumFolder, opts ...grpc.CallOption) (*JobStatus, error) {
	out := new(JobStatus)
	err := c.cc.Invoke(ctx, "/kuruvi.ExifApi/exififyAlbum", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ExifApiServer is the server API for ExifApi service.
type ExifApiServer interface {
	// A Simple RPC
	//
	// Gets the exif details of all photos in an album
	// and save it to database
	ExififyAlbum(context.Context, *AlbumFolder) (*JobStatus, error)
}

// UnimplementedExifApiServer can be embedded to have forward compatible implementations.
type UnimplementedExifApiServer struct {
}

func (*UnimplementedExifApiServer) ExififyAlbum(ctx context.Context, req *AlbumFolder) (*JobStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ExififyAlbum not implemented")
}

func RegisterExifApiServer(s *grpc.Server, srv ExifApiServer) {
	s.RegisterService(&_ExifApi_serviceDesc, srv)
}

func _ExifApi_ExififyAlbum_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AlbumFolder)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExifApiServer).ExififyAlbum(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kuruvi.ExifApi/ExififyAlbum",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExifApiServer).ExififyAlbum(ctx, req.(*AlbumFolder))
	}
	return interceptor(ctx, in, info, handler)
}

var _ExifApi_serviceDesc = grpc.ServiceDesc{
	ServiceName: "kuruvi.ExifApi",
	HandlerType: (*ExifApiServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "exififyAlbum",
			Handler:    _ExifApi_ExififyAlbum_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "kuruvi.proto",
}

// FaceApiClient is the client API for FaceApi service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type FaceApiClient interface {
	// A Simple RPC
	//
	// Gets the face details of all photos in an album
	// and save it to database
	CropAlbumFaces(ctx context.Context, in *AlbumFolder, opts ...grpc.CallOption) (*JobStatus, error)
}

type faceApiClient struct {
	cc *grpc.ClientConn
}

func NewFaceApiClient(cc *grpc.ClientConn) FaceApiClient {
	return &faceApiClient{cc}
}

func (c *faceApiClient) CropAlbumFaces(ctx context.Context, in *AlbumFolder, opts ...grpc.CallOption) (*JobStatus, error) {
	out := new(JobStatus)
	err := c.cc.Invoke(ctx, "/kuruvi.FaceApi/cropAlbumFaces", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// FaceApiServer is the server API for FaceApi service.
type FaceApiServer interface {
	// A Simple RPC
	//
	// Gets the face details of all photos in an album
	// and save it to database
	CropAlbumFaces(context.Context, *AlbumFolder) (*JobStatus, error)
}

// UnimplementedFaceApiServer can be embedded to have forward compatible implementations.
type UnimplementedFaceApiServer struct {
}

func (*UnimplementedFaceApiServer) CropAlbumFaces(ctx context.Context, req *AlbumFolder) (*JobStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CropAlbumFaces not implemented")
}

func RegisterFaceApiServer(s *grpc.Server, srv FaceApiServer) {
	s.RegisterService(&_FaceApi_serviceDesc, srv)
}

func _FaceApi_CropAlbumFaces_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AlbumFolder)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FaceApiServer).CropAlbumFaces(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kuruvi.FaceApi/CropAlbumFaces",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FaceApiServer).CropAlbumFaces(ctx, req.(*AlbumFolder))
	}
	return interceptor(ctx, in, info, handler)
}

var _FaceApi_serviceDesc = grpc.ServiceDesc{
	ServiceName: "kuruvi.FaceApi",
	HandlerType: (*FaceApiServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "cropAlbumFaces",
			Handler:    _FaceApi_CropAlbumFaces_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "kuruvi.proto",
}

// FaceCoreClient is the client API for FaceCore service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type FaceCoreClient interface {
	// A Simple RPC
	//
	// Gets the face details of all photos in an album
	// and save it to database
	DetectFaces(ctx context.Context, in *PhotoURL, opts ...grpc.CallOption) (*BoundingBoxes, error)
}

type faceCoreClient struct {
	cc *grpc.ClientConn
}

func NewFaceCoreClient(cc *grpc.ClientConn) FaceCoreClient {
	return &faceCoreClient{cc}
}

func (c *faceCoreClient) DetectFaces(ctx context.Context, in *PhotoURL, opts ...grpc.CallOption) (*BoundingBoxes, error) {
	out := new(BoundingBoxes)
	err := c.cc.Invoke(ctx, "/kuruvi.FaceCore/detectFaces", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// FaceCoreServer is the server API for FaceCore service.
type FaceCoreServer interface {
	// A Simple RPC
	//
	// Gets the face details of all photos in an album
	// and save it to database
	DetectFaces(context.Context, *PhotoURL) (*BoundingBoxes, error)
}

// UnimplementedFaceCoreServer can be embedded to have forward compatible implementations.
type UnimplementedFaceCoreServer struct {
}

func (*UnimplementedFaceCoreServer) DetectFaces(ctx context.Context, req *PhotoURL) (*BoundingBoxes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DetectFaces not implemented")
}

func RegisterFaceCoreServer(s *grpc.Server, srv FaceCoreServer) {
	s.RegisterService(&_FaceCore_serviceDesc, srv)
}

func _FaceCore_DetectFaces_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PhotoURL)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FaceCoreServer).DetectFaces(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kuruvi.FaceCore/DetectFaces",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FaceCoreServer).DetectFaces(ctx, req.(*PhotoURL))
	}
	return interceptor(ctx, in, info, handler)
}

var _FaceCore_serviceDesc = grpc.ServiceDesc{
	ServiceName: "kuruvi.FaceCore",
	HandlerType: (*FaceCoreServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "detectFaces",
			Handler:    _FaceCore_DetectFaces_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "kuruvi.proto",
}

// FaceDescribeClient is the client API for FaceDescribe service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type FaceDescribeClient interface {
	// A Simple RPC
	//
	// Gets the face details of all photos in an album
	// and save it to database
	DescribeFaces(ctx context.Context, in *DescribeFaceRequest, opts ...grpc.CallOption) (*FacePoints, error)
}

type faceDescribeClient struct {
	cc *grpc.ClientConn
}

func NewFaceDescribeClient(cc *grpc.ClientConn) FaceDescribeClient {
	return &faceDescribeClient{cc}
}

func (c *faceDescribeClient) DescribeFaces(ctx context.Context, in *DescribeFaceRequest, opts ...grpc.CallOption) (*FacePoints, error) {
	out := new(FacePoints)
	err := c.cc.Invoke(ctx, "/kuruvi.FaceDescribe/describeFaces", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// FaceDescribeServer is the server API for FaceDescribe service.
type FaceDescribeServer interface {
	// A Simple RPC
	//
	// Gets the face details of all photos in an album
	// and save it to database
	DescribeFaces(context.Context, *DescribeFaceRequest) (*FacePoints, error)
}

// UnimplementedFaceDescribeServer can be embedded to have forward compatible implementations.
type UnimplementedFaceDescribeServer struct {
}

func (*UnimplementedFaceDescribeServer) DescribeFaces(ctx context.Context, req *DescribeFaceRequest) (*FacePoints, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DescribeFaces not implemented")
}

func RegisterFaceDescribeServer(s *grpc.Server, srv FaceDescribeServer) {
	s.RegisterService(&_FaceDescribe_serviceDesc, srv)
}

func _FaceDescribe_DescribeFaces_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DescribeFaceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FaceDescribeServer).DescribeFaces(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kuruvi.FaceDescribe/DescribeFaces",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FaceDescribeServer).DescribeFaces(ctx, req.(*DescribeFaceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _FaceDescribe_serviceDesc = grpc.ServiceDesc{
	ServiceName: "kuruvi.FaceDescribe",
	HandlerType: (*FaceDescribeServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "describeFaces",
			Handler:    _FaceDescribe_DescribeFaces_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "kuruvi.proto",
}

// FaceCropClient is the client API for FaceCrop service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type FaceCropClient interface {
	// A Simple RPC
	//
	// For the given photodetails and bounding boxes,
	// crop and save faces
	CropFaces(ctx context.Context, in *CropFacesRequest, opts ...grpc.CallOption) (*JobStatus, error)
}

type faceCropClient struct {
	cc *grpc.ClientConn
}

func NewFaceCropClient(cc *grpc.ClientConn) FaceCropClient {
	return &faceCropClient{cc}
}

func (c *faceCropClient) CropFaces(ctx context.Context, in *CropFacesRequest, opts ...grpc.CallOption) (*JobStatus, error) {
	out := new(JobStatus)
	err := c.cc.Invoke(ctx, "/kuruvi.FaceCrop/cropFaces", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// FaceCropServer is the server API for FaceCrop service.
type FaceCropServer interface {
	// A Simple RPC
	//
	// For the given photodetails and bounding boxes,
	// crop and save faces
	CropFaces(context.Context, *CropFacesRequest) (*JobStatus, error)
}

// UnimplementedFaceCropServer can be embedded to have forward compatible implementations.
type UnimplementedFaceCropServer struct {
}

func (*UnimplementedFaceCropServer) CropFaces(ctx context.Context, req *CropFacesRequest) (*JobStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CropFaces not implemented")
}

func RegisterFaceCropServer(s *grpc.Server, srv FaceCropServer) {
	s.RegisterService(&_FaceCrop_serviceDesc, srv)
}

func _FaceCrop_CropFaces_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CropFacesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FaceCropServer).CropFaces(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kuruvi.FaceCrop/CropFaces",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FaceCropServer).CropFaces(ctx, req.(*CropFacesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _FaceCrop_serviceDesc = grpc.ServiceDesc{
	ServiceName: "kuruvi.FaceCrop",
	HandlerType: (*FaceCropServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "cropFaces",
			Handler:    _FaceCrop_CropFaces_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "kuruvi.proto",
}

// ResizeApiClient is the client API for ResizeApi service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ResizeApiClient interface {
	// A Simple RPC
	//
	// For the given album, resize and save to disk
	ResizePhotos(ctx context.Context, in *AlbumFolder, opts ...grpc.CallOption) (*JobStatus, error)
}

type resizeApiClient struct {
	cc *grpc.ClientConn
}

func NewResizeApiClient(cc *grpc.ClientConn) ResizeApiClient {
	return &resizeApiClient{cc}
}

func (c *resizeApiClient) ResizePhotos(ctx context.Context, in *AlbumFolder, opts ...grpc.CallOption) (*JobStatus, error) {
	out := new(JobStatus)
	err := c.cc.Invoke(ctx, "/kuruvi.ResizeApi/resizePhotos", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ResizeApiServer is the server API for ResizeApi service.
type ResizeApiServer interface {
	// A Simple RPC
	//
	// For the given album, resize and save to disk
	ResizePhotos(context.Context, *AlbumFolder) (*JobStatus, error)
}

// UnimplementedResizeApiServer can be embedded to have forward compatible implementations.
type UnimplementedResizeApiServer struct {
}

func (*UnimplementedResizeApiServer) ResizePhotos(ctx context.Context, req *AlbumFolder) (*JobStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResizePhotos not implemented")
}

func RegisterResizeApiServer(s *grpc.Server, srv ResizeApiServer) {
	s.RegisterService(&_ResizeApi_serviceDesc, srv)
}

func _ResizeApi_ResizePhotos_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AlbumFolder)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ResizeApiServer).ResizePhotos(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kuruvi.ResizeApi/ResizePhotos",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ResizeApiServer).ResizePhotos(ctx, req.(*AlbumFolder))
	}
	return interceptor(ctx, in, info, handler)
}

var _ResizeApi_serviceDesc = grpc.ServiceDesc{
	ServiceName: "kuruvi.ResizeApi",
	HandlerType: (*ResizeApiServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "resizePhotos",
			Handler:    _ResizeApi_ResizePhotos_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "kuruvi.proto",
}

// StorageApiClient is the client API for StorageApi service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type StorageApiClient interface {
	// A Simple RPC
	//
	// Saves the album details and photo details in database
	SaveFolderDetails(ctx context.Context, in *AlbumFolder, opts ...grpc.CallOption) (*JobStatus, error)
}

type storageApiClient struct {
	cc *grpc.ClientConn
}

func NewStorageApiClient(cc *grpc.ClientConn) StorageApiClient {
	return &storageApiClient{cc}
}

func (c *storageApiClient) SaveFolderDetails(ctx context.Context, in *AlbumFolder, opts ...grpc.CallOption) (*JobStatus, error) {
	out := new(JobStatus)
	err := c.cc.Invoke(ctx, "/kuruvi.StorageApi/saveFolderDetails", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// StorageApiServer is the server API for StorageApi service.
type StorageApiServer interface {
	// A Simple RPC
	//
	// Saves the album details and photo details in database
	SaveFolderDetails(context.Context, *AlbumFolder) (*JobStatus, error)
}

// UnimplementedStorageApiServer can be embedded to have forward compatible implementations.
type UnimplementedStorageApiServer struct {
}

func (*UnimplementedStorageApiServer) SaveFolderDetails(ctx context.Context, req *AlbumFolder) (*JobStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SaveFolderDetails not implemented")
}

func RegisterStorageApiServer(s *grpc.Server, srv StorageApiServer) {
	s.RegisterService(&_StorageApi_serviceDesc, srv)
}

func _StorageApi_SaveFolderDetails_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AlbumFolder)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StorageApiServer).SaveFolderDetails(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kuruvi.StorageApi/SaveFolderDetails",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StorageApiServer).SaveFolderDetails(ctx, req.(*AlbumFolder))
	}
	return interceptor(ctx, in, info, handler)
}

var _StorageApi_serviceDesc = grpc.ServiceDesc{
	ServiceName: "kuruvi.StorageApi",
	HandlerType: (*StorageApiServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "saveFolderDetails",
			Handler:    _StorageApi_SaveFolderDetails_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "kuruvi.proto",
}

// PgsqlApiClient is the client API for PgsqlApi service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type PgsqlApiClient interface {
	// A Simple RPC
	//
	// Saves the album details and photo details in database
	OrganizeData(ctx context.Context, in *AlbumFolder, opts ...grpc.CallOption) (*JobStatus, error)
}

type pgsqlApiClient struct {
	cc *grpc.ClientConn
}

func NewPgsqlApiClient(cc *grpc.ClientConn) PgsqlApiClient {
	return &pgsqlApiClient{cc}
}

func (c *pgsqlApiClient) OrganizeData(ctx context.Context, in *AlbumFolder, opts ...grpc.CallOption) (*JobStatus, error) {
	out := new(JobStatus)
	err := c.cc.Invoke(ctx, "/kuruvi.PgsqlApi/organizeData", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PgsqlApiServer is the server API for PgsqlApi service.
type PgsqlApiServer interface {
	// A Simple RPC
	//
	// Saves the album details and photo details in database
	OrganizeData(context.Context, *AlbumFolder) (*JobStatus, error)
}

// UnimplementedPgsqlApiServer can be embedded to have forward compatible implementations.
type UnimplementedPgsqlApiServer struct {
}

func (*UnimplementedPgsqlApiServer) OrganizeData(ctx context.Context, req *AlbumFolder) (*JobStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OrganizeData not implemented")
}

func RegisterPgsqlApiServer(s *grpc.Server, srv PgsqlApiServer) {
	s.RegisterService(&_PgsqlApi_serviceDesc, srv)
}

func _PgsqlApi_OrganizeData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AlbumFolder)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PgsqlApiServer).OrganizeData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kuruvi.PgsqlApi/OrganizeData",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PgsqlApiServer).OrganizeData(ctx, req.(*AlbumFolder))
	}
	return interceptor(ctx, in, info, handler)
}

var _PgsqlApi_serviceDesc = grpc.ServiceDesc{
	ServiceName: "kuruvi.PgsqlApi",
	HandlerType: (*PgsqlApiServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "organizeData",
			Handler:    _PgsqlApi_OrganizeData_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "kuruvi.proto",
}
